
## Command Argument Library - Synopsis

- [Overview](#overview)
- [Terminology](#terminology)
- [MainFunction](#mainfunction)
- [CallFunction](#callfunction)
- [CommandAction](#commandaction)
- [Work Function](#work-function)
- [Stateful Work Function](#stateful-work-function)
- [Work Function Parameter](#work-function-parameter)
- [Label-Spec](#label-spec)
- [Command Argument List](#command-argument-list)
- [Shadow Group](#shadow-group)
- [ParsedItem](#parseditem)
- [Meta-Flag](#meta-flag)
- [Show Element](#show-element)
- [Show Macro](#show-macro)
- [Dummy Show Element](#dummy-show-element)
- [Help Screen](#help-screen)
- [Manual Page](manual-page)
- [Exception](#exception)
- [Command Tree](#command-tree)
- [Command Node](#command-node)
- [Command Action](#command-action)
- [Command Work Function](#command-work-function)
- [Simple Command Tree](#simple-command-tree)

---

## Overview

The library provides three peer macros intended to annotate [work functions](SYNOPSIS.md#work-function) that execute
all or part of your program’s logic.

* MainFunction: Generates a function, `main()`, intended to be invoked by the operating system upon program initiation.
* CallFunction: Generates a function, `call(names:tokens)`, intended to be invoked by the library’s user.
* CommandAction: Generates a function, `action(tokens:nodePath:state)`, intended to be invoked by a node within
a [command tree](SYNOPSIS.md#command-tree).

By default, the permitted types for work function parameters are:

* the "basic types"`- Int`, `Double`, `String`, and `ParsedItem`
* the "flags" - `Flag` (a typealias for Bool) and `MetaFlag`
* arrays of basic types
* optional basic types

Additional basic types can be declared, but except for simple string enums, it is rarely beneficial.

In the simplest and most common case, a [work function](SYNOPSIS.md#work-function) is defined to perform the program’s logic.
After testing the function (without any macros), it can be adapted to run from the command line by annotating it with the
library’s `MainFunction` macro. The `main()` peer function generated by the macro fetches and parses the “tokens”
passed in from the command line, passes the parsed values to the work function, and handles any errors thrown
by the work function..

The tokens passed to a generated function must constitute a well-formed [command argument list](SYNOPSIS.md#command-argument-list), in which each command argument corresponds to one of the work function’s parameters. The syntax of a well-formed argument list is determined from the work function’s parameter list. There are no options (i.e., no “parsing strategies”, etc.).

"Meta-services", like help screens, manual pages, and shell completion scripts, are triggered
by [meta-flags](SYNOPSIS.md#meta-flag), which correspond to parameters with type `MetaFlag`. There are no
reserved names (like "help" or "version"), and there is no limit on the number of meta-flag parameters that can be
declared in a work function.

The library conforms to the GNU C
Library's' [program syntax argument conventions](https://sourceware.org/glibc/manual/latest/html_node/Argument-Syntax.html), with
a few minor differencees.

* Except for flags and meta-flags, command arguments must have a value.
* The library allows variadic parameters, whose arguments can include more than one value.
* If a word is parsable as a negative `Int` it will be parsed as a value, not a label (unless
it matches a specifically defined label).

A hierarchical command structure can be defined as an acyclic graph of [command nodes](SYNOPSIS.md#command-node) that can have other
command nodes as children. Each command node can be initalized with a [command action](SYNOPSIS.md#command-action) that is
best created annotating a [work function](SYNOPSIS.md#work-function) with the library's `CommandAction` macro. When a command
node is encountered, it calls its command action, passing the unconsumed portion of the original command line argument list.
The command action parses its portion of the command line argument list and passes the parsed values to its annotated work function.
If the structure's command nodes are "stateful", state can be modified and passed from parent node to child node.

---

## Terminology

The command argument syntax that can be parsed by a peer function generated by one of the library's macros
is basically a transliterated version swifit call argument syntax expected by the macro's annotate work function.

Accordingly, when discussing the library it is natural to use Swift terms
like parameter names, label names, types, default values, argument labels and argument values.

Consider this “command call,” a command’s name followed by five tokens:
```
command-name -xy --verbose --name foo file
```

The peer functions generated by the library's macros parse the tokens into [command arguments](#command-argument-list)
as follows:

* "-x", "-y" and "--verbose" are flags
* "--name foo" is a single labeled argument, not two arguments
* "file" is a "positional argument"

A flag, such as “-x”, “-y”, and “—verbose”, can be considered syntactic sugar for “-x true”, -y true,
and “—verbose=true”. Then, syntactic sugar aside, a command argument is a label value pair, where the
label is omitted for positional arguments. Exactly the same
as in Swift.

It is important to note that the term [command argument](#command-argument-list) is not the same as
the term "argument" as defined in section 25.1.1, Program Argument Syntax Conventions,
of the [GNU C Library](https://www.gnu.org/software/libc/manual/html_mono/libc.html#Argument-Syntax).

* Every word passed in from the shell is an argument.
* Arguments are options if they begin with a hyphen. The rest are non-option arguments.
* Certain options require an argument.

It is common, however, to say “argument”, instead of “non-option” argument, “option” instead of
“option that requires an argument”, and “flag” or “switch” instead of “option” that does not require an argument.

To avoid confusion, the library uses the term [command argument](#command-argument-list), which is based on Swift
conventions.

---

## MainFunction

`MainFunction` is a peer macro meant to be attached to a [work function](#work-function)
that implements your program's logic. The macro generates a peer function, `main()`, that fetches
and parses tokens passed in from the terminal, and passes the parsed values to the work function.
Any errors thrown during parsing, or by the work function, are caught and printed to stderr.

If a [work function](#work-function) is annotated by a MainFunction macro, it cannot return a value.

---

## CallFunction

`CallFunction` is a peer macro meant to be attached to a [work function](#work-function)
that implements all or a portion of your program's logic. The macro generates a peer function,
`call(names:tokens))` where names and tokens are arrays of strings. The names appear a command names in
in help and error screens. The tokens constitute as well-formed [Command Argument List](#command-argument-list).

The generated function parses the list of tokens and passes the parsed values to the work function,
returning the value returned by the work function, if any.
Any errors thrown during parsing, or by the work function, are rethrown by the generated
function.

---

## CommandAction

`CommandAction` is a peer macro meant to be attached to a [stateful work function](#stateful-work-function) or
an ordinary [work function](#work-function).

In the first case, the macro
generates a [command action](#command-action) that can be utilized to initialize a [command node](#command-node)
in a (stateful) [command tree](#simple-command-tree). In the second, the macro generates
a [command action](#command-action) that can be utilized
to initialze a [command node](#command-node) in [simple command tree](#simple-command-tree).

---

## Work Function

A “work function” is a function whose parameters are [work function parameters](#work-function-parameter). It
< can be a top-level function, a method, or a static method, be public, internal, or private, be able to throw or not, and/or
< be synchronous or asynchronous. The macros handle all of this automatically.

## Stateful Work Function

A “stateful work function” is the same as a [work function](#work-function), except that (a) it has two additional
parameters:`nodePath: [StatefulCommand<T>]` and `state: [T]`, and (b) is required to return an instance of `[T]`.
The additional parameters must appear, in order, at the end of the work function’s parameter list.

Stateful work functions are used to to constuct "stateful" command trees, in which state is passed from parent node to
child node.

---

## Work Function Parameter

A "work function parameter" has a [label-spec](#label-spec), a name, a type, and, optionally, a default value.

A parameter's [label-spec](#label-spec) determines the label, if any, of corresponding
command arguments in a [command argument list](#command-argument-list).

The types of work function parameters are limited to those in the following table:

| Type              | Default Value      | Values Per Occurance | Repeatable |
|:------------------|:-------------------|:---------------------|:-----------|
| `Basic`           | allowed            | 1                    | no         |
| `Array<Basic>`    | allowed, if `[]`   | 1                    | yes        |
| `Optional<Basic>` | implicit - `nil`   | 1                    | no         |
| `Variadic<Basic>` | allowed, if `[]`   | 1 or more            | no         |
| `Flag`            | implicit - `false` | 0                    | yes        |
| `MetaFlag`        | required           | 0                    | yes        |


`Basic` is any type that conforms to `BasicParameterType`. Out of the box, these
 are `String`, `Int`, `Double` and `ParsedItem`.

As shown in the table, a work function parameter's type determines three things:
* if a default value is allowed, implicitly defined, or required
* how many values are consumed by an associated command argument
* whether an associated command argument can appear more than once in a command argument list

If a parameter's type has an implicit value, it cannot by overriden.

A work function parameter's label-spec, type and default value (if any), determine
the syntax of corresponding command arguments and how the corresponding arguments will be parsed.

These items also determine how a parameter will be represented in generated help screens
and manual pages. In particular a parameter will be represented in a help screen or
manual page synopsis line within brackets if and only if it has an explicit or implicit default
value. Thus, for example, parameters with type Flag, MetaFlag or Optional<Basic> will always
appear within brackets.

---

## Label-Spec

A label-spec can contain only ascii alphanumeric characters and underscores, and must not start with a numeric.
If a label-spec contains exactly two underscores, the underscores delimit three "label-names", used
to generate "short", "old-style" and "long" argument labels, like "-h", "-help" and "--help". Empty label-names
are ignored. The first label-name, if not empty, must be a single letter.

If a label-spec does not contain exactly two underscores, the entire label-spec will be treated as a single label-neme.
If it consists of a single character, other than an underscore, it is used to generate a short label. If the single character
is an underscore, no label is generated. If the single label-name consists of more than one character, it is used to generate a long lobel.

If a label-name is camelcased, the generated label will be based on a snaked version of the label-name.

---

## Command Argument List

The list of tokens passed to a function generated by one of the library's macros is parsed by
the generated function into a list of "command arguments", separated by whitespace.
Each command argument is associated with a [work function parameter](#work-function-parameter)
declared by the work function annotated by the macro.

In general a command argument consists of a label and a value, e.g. "--count 10". As in Swift,
the label can be ommitted if the parameter is "positional". Arguments associated with flags and meta-flags
have no value, which is not allowed for arguments in Swift.

### Associated Labeled Arguments and Parameters

A labeled command argument is associated with a labeled parameter if the command argument's label
can be derived from the parameter's label-spec.

A labeled parameter "occurs" or "appears" in a command argument list if the list contains one or more
labeled command arguments that can be associated with the parameter. If the parameter occurs, the
associated argument's value (or an array of values if the argument is variadic) is parsed
and assigned to the parameter when main() calls the work function.

### Associated Positional Arguments and Parameters

The parser associates positional command arguments with positional parameters as follows:

* The parser begins with the first member of its list of parameters and the member of the list of unconsumed value array list.
* The parser advances through the parameters, assigning one or more of the elements of the current
unconsummd value array to each parameter until the array is exhausted.
* The parser then moves to the next parameter and the next array of unconsummed values.

The net effect is that positional values are "permuted" to the end of the arguments list as is
common with many argument parsers (e.g., getopt), except that each variadic argument list is
treated as a seperate value.

---

## Shadow Group

A shadow group is a group of parameters that override each other. If more than one member of a group
appears in a command argument list, only the last one will be parsed.

---

## ParsedItem

A ParsedItem is a struct that is useful when the order of the elements of a command argument list
must be considered.

```swift
public struct ParsedItem: Sendable, BasicParameterType {
    public let parameterName: String
    public internal(set) var position: Int
    public internal(set) var values: [String]
    public internal(set) var label: String?
}
```

It is reccommened that `ParsedItem` be avoided.

---

## Meta-Flag

A "meta-flag" is a parameter with type `MetaFlag`, a struct that has a custom `MetaFlagFunction`, like this:

```swift
public typealias MetaFlagFunction = @Sendable (
    [String],           // call names
    PeerFunctionConfig  // configuration info of the generated peer function
) -> Exception
```

Parameters with type `MetaFlag` must provide a default value.

When parameter with type `MetaFlag` is encountered during parsing:

* the parameter's default value's MetaFlagfunction is called
* the `Exception` returned has a message that is printed
* the program ends with exit code EXIT_FAILURE

A work function can contain any number of meta-flags. All meta-flags automatically
shadow each other, so at most one meta-flag will be invoked in a command call.

The library provides a few built-in `MetaFlag` intializers. These cover the most common uses:
help screens, man page generators, and text messages.

---

## Show Element

Show elements are used to lay out help screens and manual pages in terms of text elements,
line elements, synopsis elements, and parameter description elements.

A text element has an optional header and an optional body. The body is automatically
line-wrapped. The body can start on the same line as the header with hanging indent or on the line
after the header with basic indent, which defaults to 2. A line element is the same
except that the body is not line wrapped. (Especially useful for when laying out
a manual page). The bodies of text and line elements can contain [show macros](#show-macro),

A synopsis element has a header and a body that consists of an array of lists of parameter names. Each
list is rendered as a line-wrapped list of parameter syntax descriptions, like "[-n \<name\\>]".
Parameters of type Flag or MetaFlag that have a short label are packed at the start of each rendered
synopsis line.
The synopsis line can rendered starting on the same line as the header or starting on the first
line after the header. If the synopsis element's body is empty a default body is generated. The
default is a single listl that includes all of the annotated work function's parameters, except
for meta-flags that don't have a short label. In the default list, the parameters appear in
the order that they appear in the annotated work function.

Each parameter description element has a parameter name and a parameter synoposis.
The synopsis can contain [show macros](#show-macro).
A parameter description element has a third field, used to provide hints to shell completion script generators.

## Dummy Show Element

If the library does not recognize a parameter name when generating
a help screen or man page synopsis element it checks to see if the name has the form "<label-spec>:<type>". If so
it will generate a required (i.e., not bracketed) dummy synopsis element, formatted as if it were a parameter
with the given label-spec and type, with no default value.

## Show Macro

It is often useful to insert a work function parameter's label and/or type in
help screen text and manual page text. The libray provides the following
"show macros", which can be inserted in text that appears in [show elements](#show-element)
or in error screen. When the show element or error screen is rendered, the macro will be expanded
appropriately. The type macros will be formatted in the error screen using
the type formatter set in the governing MetaFlag, if any.

There are four show macros:

* `$S{<parameter-name>}` - the parameter's shortest label
* `$L{<parameter-name>}` - the parameter's longest label
* `$T{<parameter-name>}` - the parameter's type
* `$E{<parameter-name>}` - the type of the parameter's elements

In manual page text, the format of labels and types is fixed by the mdoc utitity.

---

## Help Screen

A help screen made available by adding a "help-meta-flag", a meta-flag that has a default
value initialized with `MetaFlag(helpElements: [ShowElement])`.

The  [showElements](#show-element) define the layout of text, synopsis lines, and parameter descriptions to be included
in the help screen.

By default, meta-flags are not included in the synopsis line, unless they have a short label,
in which case the short label is included. Parameters are represented
in the synopsis line in the order they appear in the work function, except that flags with
short names are packed at the front. Other parts of the help screen appear in the order that they appear
in the array of ShowElements.

Parameters that have an explicit or implicit default value are
are "optional", and are not requred to appear in the command argument list. They are
enclosed in brackets in the synopsis line. Those that do not have default values
are "required", must appear at least once in the command argument list, and
are not enclosed in brackets.

The default typeFormatter converts camelcased type names, like "FileName" to angle-braketed
snaked name like "<file-name>". A "SymbolFormatter" can be configured customize case, brackets,
snake separators and styles (like bold or underline).

The Library cannot detect, at compile time, if a parameter
description has a unrecognized parameter name. If this is detected, at run time, the library
will stop your program and issue a "programmer error" message when the help meta-flag is triggered.

---

## Manual Page

The library can generate mdoc documents, which can be rendered by man in less.

A manual page is defined by a meta-flag whose default value is an instance of `MetaFlag(mdocElements: [ShowElement])`.
The ShowElements are the same as for help screen meta-flags, except that the first two elements
must be a "prologue" show element followed by a synopis show element with header "SYNOPSIS".
The prologue element, unique to manual page layouts, provides the description, date
and operating system info that mdoc requires.

Native "mdoc text" can be included in a show element array as line show elements. When converting an array
of help screen elements to an arry of mdocElements, it is recommended that all text
elements be converted to line elements (e.g., s/text/line/g).

---

## Exception

The library provides a type, `Exception`, that conforms to `Error`, `CustomStringConvertible`, and `Sendable`.
It has three public initializers that create exceptions that can be thrown by a work function.

```swift
/// Intended to be printed to stdout
Exception(message: String)

/// Intended to be printed to stderr
Exception(errorMessage: String)

/// Used to populate the error screen which is intended to be printed to stderr
Exception(handledErrors: [String])
```

---

## Command Tree

A “command tree” is a directed acyclic graph of [command nodes]([#command-node), i.e., a node can be reached
by more than one path, but circular paths are prohibited (a compile-time error).

All instances of a given command tree must have the same type.< `StatefulCommand<T:Sendable>`, where `T` can be
any sendable type. Each node has a `run` method that is called with a [command argument list](#command-argument-list),
a “node path” and a state, of type `[T]`. The run method uses a portion of the list, the node path, and the state to
make a new state. If the run method uses all of the argument list, it returns the empty list and the new state.
Otherwise, it recursively calls the run method of one of its children, passing it the unconsumed portion of the
argument list, the new node path, and the new state.

A command tree is "run" by calling the run method of its top-level node, passing
a [command argument list](#command-argument-list), an empty node path, and an empty state.

---

## Command Node

A command node is an instance of `StatefulCommand<T:Sendable>`, where `T` is any sendable type.

Along with other properties, a command node has a name, an array of child nodes,
a [command action](#command-action), and a `run` method. All of the child nodes must have the
same type as their parent.

A command node's `run` method is defined as follows:

```swift
// Run the current node
/// - Parameters:
///   - tokens: an acceptable tokens list
///   - nodePath: The StatefulCommands traversed to arrive here
///   - state: The current state
/// - Returns: A new state and unconsumed command line arguments
@discardableResult public func run(
    tokens: [String],
    nodePath: [StatefulCommand] = [],
    state: [T] = []
) async throws -> (newState: [T], unconsummedWords: [String]) { ... }
```

A list of tokens is acceptable to the current node's `run` method if it

* begins with a list tokens that can be parsed by current node's command action
* is followed by a tail that
  * is empty
  * or is the name of one of the current node's children, followed by a tokens list acceptable to the named child node

The current node's `run` method calls the node's command action which:

* Consumes the tokens list until it encounters an “unconsumed” token that is the name of one of its children.
* Executes its [command action](#command-action), if any, to perform program logic and/or verify meta-flags, resulting in a new state.
* Returns the new state and the unconsumed portion of the token list.

If the unconsumed token list returned by the command action is empty, the `run` method returns the new state and the empty list.

Otherwise, it is an error if the unconsumed token list is not the name of one of the node's children. Assuming no errors,
the `run` method constructs a new token list by removing the name from the front of the unconsumed token list, and
a new node path by appending the named child to the current node path. The `run` method then recursively calls
the named child node's `run` method with the new token list, new node path, and new state returned by its command action.

---

## Command Action

The library defines a command action as follows:

```swift
/// A function that can be used by a StatefulCommands
public typealias StatefulCommandAction<T:Sendable> = @Sendable (
    [String],  // tokens
    [StatefulCommand<T>],  // run path, ending with self
    [T]  // state
) async throws -> (
    [T],  // new state
    [String]  // remaining uparsed tokens
)
```

The most straightforward way to define a command action is to annotate a [command work function](#command work function)
with the `CommandAction` macro.

The primary advantage of utilizing the `CommandAction` macro lies in its ability to parse command arguments
and transmit the parsed values to the annotated work function, akin to the behavior of a work function
annotated with the `MainFunction` macro.

___

## Command Work Function

An command work function is the same a
normal [work function](https://github.com/psummerland/CmdArgLibExamples_MainFunction?tab=readme-ov-file#work-function) except
that (a) it has two additional parameters`nodePath: [StatefulCommand<T>]` and `state: [T]`, and (b) is required
to return an instance of `[T]`. The additional parameters must appear, in order, at the end of the work function's
parameter list.

A command work function is analogous to a standard work function, with the exception that it requires
two additional parameters: `nodePath: [StatefulCommand<T>]` and `state: [T]`. Furthermore, it is mandatory
for the work function to return an instance of `[T]`. These additional parameters must be presented in the
order specified at the end of the work function’s parameter list.

---

## Simple Command Tree

In many cases, the sole node that influences program logic when a top-level tree is executed is the final
node encountered. Consequently, all child nodes operate independently of any state passed by parent trees.

 As a syntactic convenience for managing such “simple command trees,” the library defines `SimpleCommand`
 as a typealias for `StatefulCommand<Void>`. Additionally, if `CommandAction` annotates a work function
 that lacks `nodePath` and `state` parameters and does not return a value, the macro will generate a command
 action of type `StatefulCommandAction<Void>` that processes the `nodePath` and `state` arguments independently
 without involving the work function (except for meta-flag parameters).

---
